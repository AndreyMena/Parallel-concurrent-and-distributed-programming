struct sharedData
  inputsVector  // all read number
  numOfSumsVector  // number of goldbach's sums for each line read
  listArrThreeField  // Array List of three fields for goldbach's solution fact
  thread_count
  can_acces_position  // A mutex
  position
end struct

struct private_data
  thread_number
  sharedData
  index
end struct

procedure main(argc , argv[])
  create sharedData
  sharedData.thread_count := integer(argv[1])
  readStdin(sharedData)
  goldbachCalc := create_goldbachCalc()  // A goldbach's calculator
  goldbachCalc_run(sharedData)
  printResult(sharedData)
end procedure

procedure readStdin(sharedData)
  int64 number := 0
  while read_from_standard_input(&number) == true do
    if is_number_of_64_bits
      store in sharedData.inputsVector[indexLine]: number
    else
      break  //Stop reading
  end while
end procedure

procedure goldbachCalc_run(sharedData)
  set memory for (sharedData.listArrThreeField, inputsVector.size)
  if inputsVector.size < sharedData.thread_count do
    sharedData.thread_count := sharedData.inputsVector.size
  end if
  set memory for (private_data, sharedData.thread_count)

  sharedData.position = thread_count-1

  for threadNumber := 0 to sharedData.thread_count do
    private_data[thread_number].threadNumber := threadNumber
    private_data[thread_number].index := threadNumber
    private_data[thread_number].sharedData := sharedData

    create_thread(goldbachCalc_directThreads, sharedData, private_data)
  end for
  
  for threadNumber := 0 to sharedData.thread_count do
    join_thread(thread[threadNumber])
  end
end procedure

procedure goldbachCalc_directThreads(sharedData, private_data)
  number := sharedData.inputsVector[private_data.index]
  finish = 0
  while (finish == 0) {
    if number < 0
      number = number * -1
    if (number % 2 == 0)
      goldbachCalc_strongConject(number, private_data, sharedData, index) // Even number
    else
      goldbachCalc_weakConject(number, private_data, index) // Odd number

    lock(sharedData.can_acces_position)
    sharedData.position++
    private_data.index := sharedData.position
    if private_data.index >= sharedData.inputsVector.size
      finish = 1
    else
      number = sharedData.inputsVector[private_data.index]
    unlock(sharedData.can_acces_position)
  }
end procedure

// Adaptado de <https://www.youtube.com/watch?v=ROEnh3ji-Oc>
procedure goldbachCalc_strongConject(number, private_data, sharedData, index)
  counterOfGoldbachsSolutions := 0
  firstPrim* = set memory with number;
  secondPrim = set memory with number;
  thirdPrim = set memory with number;
  if (0 <= number <= 5 )
    store in sharedData.listArrThreeField[index]: 0, 0, 0
  else
    counterOfGoldbachsSolutions := 0
    #pragma omp parallel for 
    for firstPrimeNumber := 2 to number do
      secondPrimeNumber = number-firstPrimeNumber
      if firstPrimeNumber <= secondPrimeNumber
        if isPrime(firstPrimeNumber)
          if isPrime(secondPrimeNumber)
            counterOfGoldbachsSolutions++

            posicion = firstPrimeNumber;
            firstPrim[posicion] = firstPrimeNumber;
            secondPrim[posicion] = secondPrimeNumber;
            thirdPrim[posicion] = thirdPrimeNumber;            
    end for
    store in sharedData.listArrThreeField[index]:
      firstPrim, secondPrim, thirdPrim    
    store counterOfGoldbachsSolutions in sharedData   //num of sums vector
end procedure

procedure goldbachCalc_weakConject(number, sharedData, private_data, index)
  counterOfGoldbachsSolutions := 0
  maxPrimePosible = (number * 0.33);
  maxCapacity = ((number * 0.34) * (number * 0.34));
  firstPrim* = set memory with maxCapacity;
  secondPrim = set memory with maxCapacity;
  thirdPrim = set memory with maxCapacity; 
  if (0 <= number <= 5 )
    store in sharedData.listArrThreeField[index]: 0, 0, 0
  else
    omp parallel for
    for firstPrimeNumber := 2 to number do
      if isPrime(firstPrimeNumber)
        for secondPrimeNumber := 2 to number do
          thirdPrimeNumber = number-
            (firstPrimeNumber+secondPrimeNumber);
          if firstPrimeNumber <= secondPrimeNumber && secondPrimeNumber
            <= thirdPrimeNumber
            if isPrime(secondPrimeNumber)
              if isPrime(thirdPrimeNumber)
                omp atomic
                counterOfGoldbachsSolutions++

                int64_t posicion = (maxPrimePosible * (firstPrimeNumber-2)) + secondPrimeNumber;
                firstPrim[posicion] = firstPrimeNumber;
                secondPrim[posicion] = secondPrimeNumber;
                thirdPrim[posicion] = thirdPrimeNumber;

                
              end for
            end for
  store in sharedData.listArrThreeField[index]:
    firstPrim, secondPrim, thirdPrim
  store counterOfGoldbachsSolutions in sharedData   //num of sums vector
end procedure

procedure isPrime(number)
  if number < 2
    return 0  //it isn't prime
  else
    if number  == 2
      return 1
    if numer % 2 == 0
      return 0
    sqrtNumber = sqrt(number)  
    for prime := 3 to prime < sqrtNumber; prime+=2 do
      if number % prime == 0
        return 0  //it isn't prime
    end for
    return 1  //it's prime


end procedure

procedure printResult(sharedData)
  for index := 0 to inputsVector.size do
    print sharedData.inputsVector[index] + ": "
    if sharedData.numOfSumsVector[index] == 0
      print "NA"
    else
      print sharedData.numOfSumsVector[index] + "sums"
      if sharedData.inputsVector[index] < 0   //If the number is negative
        print ": "
        for (indexArr : = 0 to listArrThreeField[[index]].size do
          if ((inputsVector[index] * -1) % 2 == 0)
            print sharedData.listArrThreeField[index].firstPrimeNumber[indexArr] + " + "
            print sharedData.listArrThreeField[index].secondPrimeNumber[indexArr]
          else
            print sharedData.listArrThreeField[index].firstPrimeNumber[indexArr] + " + "
            print sharedData.listArrThreeField[index].secondPrimeNumber[indexArr] + " + "
            print sharedData.listArrThreeField[index].thirdPrimeNumber[indexArr]
          if indexArr != listArrThreeField[index].size - 1
            print ", " 
        end for
    print "\n"
  end for
end procedure