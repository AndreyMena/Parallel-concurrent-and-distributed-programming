
// Problem formulation

/*
• Only one philosopher can hold a fork at a time.
• YES It must be impossible for a deadlock to occur.
• NO It must be impossible for a philosopher to starve waiting for a fork.
• YES It must be possible for more than one philosopher to eat at the same time.
*/

// Same as s2a but using data parallelism
// Solution is symetric

main:
	shared NUM_PHILOS = 5 
	shared semaphore[] fork = { 1, 1, 1, 1, 1 }
	for i in range(NUM_PHILOS) 
		create_thread(philosopher(i)

philosopher(int i):
	While (true)
		// think for a bounded amount of time
		think()	
		// prior to eat, the philosopher must acquire both  right and left forks
		get_forks(i)
		// each for a bounded amount of time
		eat()
		// release the forks so that another philosoper can eat
		put_forks(i)

get_forks(int i):
	firstChoice = min(i, (i + 1) % NUM_PHILOS])
	secondChoice = max(i, (i + 1) % NUM_PHILOS])

	wait(fork[firstChoice])
	wait(fork[secondChoice])

put_forks(int i):
	signal(fork[i])
	signal(fork[ (i + 1) % NUM_PHILOS])














--> No deadlock since at least one philosopher attempts to hold the left fork first 


