struct sharedData
  inputsVector  // all read number
  numOfSumsVector  // number of goldbach's sums for each line read
  listArrThreeField  // Array List of three fields for goldbach's solution fact
  thread_count
  can_acces_position  // A mutex
  position
  processOrder
end struct

struct private_data
  thread_number
  sharedData
  index
end struct

procedure send_rec_data(shared_data, process_number, process_count)
  // Enviamos el size de entradas a todos los procesos, para almacenar espacio.
  MPI_Bcast(shared_data->processOrder, shared_data->inputsArray.size, /*source*/0)

  for (index = 0; index < shared_data->processOrder.size do
    int readyForSendRec = -1

    if (process_number == 0) {
      readyForSendRec = 1;
      int64_t correspondingProcess = shared_data->processOrder.elements[index];
      MPI_Send(readyForSendRec, 1, correspondingProcess,  0)
      MPI_Recv(shared_data->numOfSumsArray[index], 1, correspondingProcess,  1,)
      int64_t maxCapacity = -1;
      MPI_Recv(maxCapacity, 1, correspondingProcess,  2)
      MPI_Recv(shared_data->listArrayResult[index].firstField, maxCapacity, correspondingProcess,  3)
      MPI_Recv(shared_data->listArrayResult[index].secondField, maxCapacity, correspondingProcess,  4)
      MPI_Recv(shared_data->listArrayResult[index].thirdField, maxCapacity, correspondingProcess,  5)
    }

    if (process_number == shared_data->processOrder[index]) {
      MPI_Recv(readyForSendRec, 1, 0,  0)
      
      MPI_Send(shared_data->numOfSumsArray[index], 1,  0,  1)

      int64_t capacity = shared_data->listArrayResult[index].size
      MPI_Send(capacity, 1, MPI_INT64_T, 0,  2)
      
      MPI_Send(shared_data->listArrayResult[index].firstField, capacity,,  0,  3)
      MPI_Send(shared_data->listArrayResult[index].secondField, capacity,,  0,  4)
      MPI_Send(shared_data->listArrayResult[index].thirdField, capacity,,  0,  5)
    }
  end for
end procedure

procedure main(argc , argv[])
  MPI_Init()
  int process_number = -1;
  MPI_Comm_rank(process_number)
  int process_count = -1;
  MPI_Comm_size(process_count)
  create sharedData
  sharedData.thread_count := integer(argv[1])
  readStdin(sharedData)
  goldbachCalc := create_goldbachCalc()  // A goldbach's calculator
  goldbachCalc_run(sharedData, process_number, process_count)
  if process_number == 0
    printResult(shared_data);
  send_rec_data(shared_data, process_number, process_count);
  printResult(sharedData)
  MPI_Finalize
end procedure

procedure readStdin(sharedData)
  int64 number := 0
  while read_from_standard_input(&number) == true do
    if is_number_of_64_bits
      store in sharedData.inputsVector[indexLine]: number
    else
      break  //Stop reading
  end while
end procedure

procedure goldbachCalc_run(sharedData, process_number, process_count)
  set memory for (sharedData.listArrThreeField, inputsVector.size)
  if inputsVector.size < sharedData.thread_count do
    sharedData.thread_count := sharedData.inputsVector.size
  end if
  set memory for (private_data, sharedData.thread_count)

  index = 0;
  if (process_number == 0)
    //Envio inicial
    for (process = 1; process <= process_count; process++) {
      couldContinue = 1;
      MPI_Send(couldContinue, /*target*/ process, /*tag*/ 0)
      MPI_Send(index, /*target*/ process, /*tag*/ 0)
      int64_t number = shared_data.inputsArray[process-1]
      MPI_Send(number, /*target*/ process, /*tag*/ 0)
      pushBack(shared_data->processOrder, process)
      index++;
    }

    // Envio dinamico
    while index < shared_data->inputsArray.size do
      readyForMore = 0
      MPI_Status status
      MPI_Recv(readyForMore, MPI_ANY_SOURCE, /*tag*/ 0, status)
      if (readyForMore == 1) {
        number = shared_data->inputsArray.elements[index]
        couldContinue = 1
        MPI_Send(couldContinue, /*target*/ status.MPI_SOURCE, /*tag*/ 0)
        MPI_Send(index, /*target*/ status.MPI_SOURCE, /*tag*/ 0)
        MPI_Send(number, /*target*/ status.MPI_SOURCE, /*tag*/ 0)
      }
      pushBack(shared_data->processOrder, status.MPI_SOURCE)
      index++
    end while

    // Condiciones de parada
    for process = 1; process < process_count do
      readyForMore = 0
      MPI_Recv(readyForMore, process, /*tag*/ 0)
      couldContinue = 0
      MPI_Send(couldContinue, /*target*/ process, /*tag*/ 0)
    end for
  else if
    goldbachCalc_mpi_rec_dynamic(shared_data, process_number, process_count)
  end if
end procedure

procedure goldbachCalc_mpi_rec_dynamic(shared_data, process_number, process_count)
  while (1) {
    int64_t number = 0
    int couldContinue = 0
    uint64_t index = 0
    MPI_Recv(couldContinue, /*source*/ 0, /*tag*/ 0,)
    // Condicion de parada.
    if couldContinue == 0
      break
    end if

    MPI_Recv(index, /*source*/ 0, /*tag*/ 0)
    MPI_Recv(number, /*source*/ 0 , /*tag*/ 0,)

    int negative = 0
    if number < 0
      number = number * - 1  // To negative
      negative = 1
    end if

    if number % 2 == 0
      // Even number
      error = goldbachCalc_strongConject(number, shared_data, index, negative)
    else 
      // Odd number
      error = goldbachCalc_weakConject(number, shared_data, index, negative)
    end if

    int readyForMore = 1
    MPI_Send(readyForMore, /*target*/ 0, /*tag*/ 0)
  }
end procedure

procedure goldbachCalc_directThreads(sharedData, private_data)
  number := sharedData.inputsVector[private_data.index]
  finish = 0
  while (finish == 0) {
    if number < 0
      number = number * -1
    if (number % 2 == 0)
      goldbachCalc_strongConject(number, private_data, sharedData, index) // Even number
    else
      goldbachCalc_weakConject(number, private_data, index) // Odd number

    lock(sharedData.can_acces_position)
    sharedData.position++
    private_data.index := sharedData.position
    if private_data.index >= sharedData.inputsVector.size
      finish = 1
    else
      number = sharedData.inputsVector[private_data.index]
    unlock(sharedData.can_acces_position)
  }
end procedure

// Adaptado de <https://www.youtube.com/watch?v=ROEnh3ji-Oc>
procedure goldbachCalc_strongConject(number, private_data, sharedData, index)
  counterOfGoldbachsSolutions := 0
  firstPrim* = set memory with number
  secondPrim = set memory with number
  thirdPrim = set memory with number
  if (0 <= number <= 5 )
    store in sharedData.listArrThreeField[index]: 0, 0, 0
  else
    counterOfGoldbachsSolutions := 0
    #pragma omp parallel for 
    for firstPrimeNumber := 2 to number do
      secondPrimeNumber = number-firstPrimeNumber
      if firstPrimeNumber <= secondPrimeNumber
        if isPrime(firstPrimeNumber)
          if isPrime(secondPrimeNumber)
            counterOfGoldbachsSolutions++

            posicion = firstPrimeNumber
            firstPrim[posicion] = firstPrimeNumber
            secondPrim[posicion] = secondPrimeNumber
            thirdPrim[posicion] = thirdPrimeNumber       
    end for
    store in sharedData.listArrThreeField[index]:
      firstPrim, secondPrim, thirdPrim    
    store counterOfGoldbachsSolutions in sharedData   //num of sums vector
end procedure

procedure goldbachCalc_weakConject(number, sharedData, private_data, index)
  counterOfGoldbachsSolutions := 0
  maxPrimePosible = (number * 0.33)
  maxCapacity = ((number * 0.34) * (number * 0.34))
  firstPrim* = set memory with maxCapacity
  secondPrim = set memory with maxCapacity
  thirdPrim = set memory with maxCapacity
  if (0 <= number <= 5 )
    store in sharedData.listArrThreeField[index]: 0, 0, 0
  else
    omp parallel for
    for firstPrimeNumber := 2 to number do
      if isPrime(firstPrimeNumber)
        for secondPrimeNumber := 2 to number do
          thirdPrimeNumber = number-
            (firstPrimeNumber+secondPrimeNumber)
          if firstPrimeNumber <= secondPrimeNumber && secondPrimeNumber
            <= thirdPrimeNumber
            if isPrime(secondPrimeNumber)
              if isPrime(thirdPrimeNumber)
                omp atomic
                counterOfGoldbachsSolutions++

                int64_t posicion = (maxPrimePosible * (firstPrimeNumber-2)) + secondPrimeNumber
                firstPrim[posicion] = firstPrimeNumber
                secondPrim[posicion] = secondPrimeNumber
                thirdPrim[posicion] = thirdPrimeNumber

                
              end for
            end for
  store in sharedData.listArrThreeField[index]:
    firstPrim, secondPrim, thirdPrim
  store counterOfGoldbachsSolutions in sharedData   //num of sums vector
end procedure

procedure isPrime(number)
  if number < 2
    return 0  //it isn't prime
  else
    if number  == 2
      return 1
    if numer % 2 == 0
      return 0
    sqrtNumber = sqrt(number)  
    for prime := 3 to prime < sqrtNumber prime+=2 do
      if number % prime == 0
        return 0  //it isn't prime
    end for
    return 1  //it's prime


end procedure

procedure printResult(sharedData)
  for index := 0 to inputsVector.size do
    print sharedData.inputsVector[index] + ": "
    if sharedData.numOfSumsVector[index] == 0
      print "NA"
    else
      print sharedData.numOfSumsVector[index] + "sums"
      if sharedData.inputsVector[index] < 0   //If the number is negative
        print ": "
        for (indexArr : = 0 to listArrThreeField[[index]].size do
          if ((inputsVector[index] * -1) % 2 == 0)
            print sharedData.listArrThreeField[index].firstPrimeNumber[indexArr] + " + "
            print sharedData.listArrThreeField[index].secondPrimeNumber[indexArr]
          else
            print sharedData.listArrThreeField[index].firstPrimeNumber[indexArr] + " + "
            print sharedData.listArrThreeField[index].secondPrimeNumber[indexArr] + " + "
            print sharedData.listArrThreeField[index].thirdPrimeNumber[indexArr]
          if indexArr != listArrThreeField[index].size - 1
            print ", " 
        end for
    print "\n"
  end for
end procedure